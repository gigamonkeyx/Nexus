{
  "name": "research-agent",
  "description": "An agent specialized in conducting research and gathering information",
  "capabilities": ["research", "information_retrieval", "summarization"],
  "files": [
    {
      "path": "src/index.ts",
      "content": "/**\n * {{name}}\n * \n * {{description}}\n */\n\nimport {\n  NexusClient,\n  AdapterManager,\n  AgentCommunication,\n  TaskManager,\n  logger,\n  LogLevel,\n  BaseAgentConfig\n} from 'bootstrap-core';\nimport { ResearchAgent } from './ResearchAgent';\nimport * as path from 'path';\n\n// Set log level to debug for more detailed logging\nlogger.setLevel(LogLevel.DEBUG);\n\n/**\n * Main function\n */\nasync function main() {\n  try {\n    // Create NexusClient\n    const nexusClient = new NexusClient();\n    \n    // Register servers\n    const servers = ['ollama'];\n    \n    servers.forEach(server => {\n      nexusClient.registerServer(server, {\n        type: 'sse',\n        url: `http://localhost:${getPortForServer(server)}/sse`\n      });\n    });\n    \n    // Connect to servers\n    for (const server of servers) {\n      try {\n        await nexusClient.connectServer(server);\n        logger.info(`Connected to ${server} server`);\n      } catch (error) {\n        logger.warn(`Failed to connect to ${server} server: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n    \n    // Create AdapterManager\n    const adapterManager = new AdapterManager(nexusClient);\n    \n    // Create AgentCommunication\n    const agentCommunication = new AgentCommunication(nexusClient, {\n      workspacePath: path.join(process.cwd(), '..', '..', 'agent-workspace')\n    });\n    \n    // Create Agent\n    const agentConfig: BaseAgentConfig = {\n      name: '{{name}}',\n      description: '{{description}}',\n      workspacePath: path.join(process.cwd(), '..', '..', 'agent-workspace'),\n      taskSpecsPath: path.join(process.cwd(), '..', '..', 'mcp-client', 'tasks', '{{agentId}}-tasks.md'),\n      outputPath: path.join(process.cwd(), '..', '..', 'mcp-client', 'src', 'output'),\n      collaborators: {}\n    };\n    \n    const agent = new ResearchAgent(\n      nexusClient,\n      adapterManager,\n      agentCommunication,\n      agentConfig\n    );\n    \n    // Initialize the agent\n    await agent.initialize();\n    \n    // Start the agent\n    await agent.start();\n    \n    // Keep the process running\n    logger.info('{{name}} is running. Press Ctrl+C to stop.');\n    \n    // Handle process termination\n    process.on('SIGINT', async () => {\n      logger.info('Stopping {{name}}...');\n      await agent.stop();\n      process.exit(0);\n    });\n  } catch (error) {\n    logger.error(`Error in main: ${error instanceof Error ? error.message : String(error)}`);\n    process.exit(1);\n  }\n}\n\n/**\n * Get port for a server\n */\nfunction getPortForServer(server: string): number {\n  // Default ports for common servers\n  const serverPorts: Record<string, number> = {\n    'ollama': 3011,\n    'code-enhancement': 3020,\n    'lucidity': 3021,\n    'github': 3022,\n    'mcp-benchmark-server': 8020\n  };\n  \n  return serverPorts[server] || 3000;\n}\n\n// Run the main function\nmain().catch(error => {\n  logger.error(`Unhandled error: ${error instanceof Error ? error.message : String(error)}`);\n  process.exit(1);\n});"
    },
    {
      "path": "src/ResearchAgent.ts",
      "content": "/**\n * {{name}}\n * \n * {{description}}\n */\n\nimport {\n  NexusClient,\n  AdapterManager,\n  AgentCommunication,\n  TaskManager,\n  Message,\n  BaseAgentConfig,\n  logger,\n  LogLevel,\n  AgentInfo,\n  TaskSpecification\n} from 'bootstrap-core';\nimport { ResearchTask } from './ResearchTask';\nimport { ResearchResult } from './ResearchResult';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport class ResearchAgent {\n  private nexusClient: NexusClient;\n  private adapterManager: AdapterManager;\n  private agentCommunication: AgentCommunication;\n  private taskManager: TaskManager;\n  private config: BaseAgentConfig;\n  private agentId: string;\n  private tasks: TaskSpecification[] = [];\n  private currentTask: TaskSpecification | null = null;\n  private messageCheckInterval: NodeJS.Timeout | null = null;\n  private researchTasks: Map<string, ResearchTask> = new Map();\n  \n  constructor(\n    nexusClient: NexusClient,\n    adapterManager: AdapterManager,\n    agentCommunication: AgentCommunication,\n    config: BaseAgentConfig\n  ) {\n    this.nexusClient = nexusClient;\n    this.adapterManager = adapterManager;\n    this.agentCommunication = agentCommunication;\n    this.config = config;\n    this.agentId = `{{agentId}}`;\n    \n    // Initialize task manager\n    this.taskManager = new TaskManager(this.agentId, this.agentCommunication);\n  }\n  \n  /**\n   * Initialize the agent\n   */\n  public async initialize(): Promise<void> {\n    logger.info(`Initializing ${this.config.name}...`);\n    \n    try {\n      // Register with communication system\n      this.agentCommunication.registerAgent({\n        id: this.agentId,\n        name: this.config.name,\n        type: 'research-agent',\n        capabilities: ['research', 'information_retrieval', 'summarization'],\n        status: 'idle'\n      });\n      \n      // Load task specifications\n      await this.loadTaskSpecifications();\n      \n      // Start message checking\n      this.startMessageChecking();\n      \n      logger.info(`${this.config.name} initialized successfully`);\n    } catch (error) {\n      logger.error(`Failed to initialize ${this.config.name}: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n  \n  /**\n   * Start the agent\n   */\n  public async start(): Promise<void> {\n    logger.info(`Starting ${this.config.name}...`);\n    \n    try {\n      // Update status\n      this.agentCommunication.updateAgentStatus(this.agentId, 'busy');\n      \n      // Process any existing messages\n      await this.processMessages();\n      \n      // Start working on tasks\n      await this.startWorking();\n      \n      logger.info(`${this.config.name} started successfully`);\n    } catch (error) {\n      logger.error(`Error starting ${this.config.name}: ${error instanceof Error ? error.message : String(error)}`);\n      this.agentCommunication.updateAgentStatus(this.agentId, 'idle');\n    }\n  }\n  \n  /**\n   * Stop the agent\n   */\n  public async stop(): Promise<void> {\n    logger.info(`Stopping ${this.config.name}...`);\n    \n    // Stop message checking\n    if (this.messageCheckInterval) {\n      clearInterval(this.messageCheckInterval);\n      this.messageCheckInterval = null;\n    }\n    \n    // Update status\n    this.agentCommunication.updateAgentStatus(this.agentId, 'offline');\n    \n    logger.info(`${this.config.name} stopped successfully`);\n  }\n  \n  /**\n   * Load task specifications\n   */\n  private async loadTaskSpecifications(): Promise<void> {\n    try {\n      // Check if task specs file exists\n      if (fs.existsSync(this.config.taskSpecsPath)) {\n        const content = fs.readFileSync(this.config.taskSpecsPath, 'utf-8');\n        \n        // Parse tasks from markdown\n        this.tasks = this.parseTasksFromMarkdown(content);\n        \n        logger.info(`Loaded ${this.tasks.length} tasks from specifications`);\n      } else {\n        logger.warn(`Task specifications file not found: ${this.config.taskSpecsPath}`);\n      }\n    } catch (error) {\n      logger.error(`Error loading task specifications: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  /**\n   * Parse tasks from markdown\n   */\n  private parseTasksFromMarkdown(markdown: string): TaskSpecification[] {\n    // Use the TaskManager's parseTasksFromMarkdown method\n    return this.taskManager.parseTasksFromMarkdown(markdown);\n  }\n  \n  /**\n   * Start message checking\n   */\n  private startMessageChecking(): void {\n    // Check for new messages every 5 seconds\n    this.messageCheckInterval = setInterval(async () => {\n      await this.processMessages();\n    }, 5000);\n  }\n  \n  /**\n   * Process messages\n   */\n  private async processMessages(): Promise<void> {\n    try {\n      // Get unread messages\n      const messages = this.agentCommunication.getUnreadMessagesForAgent(this.agentId);\n      \n      for (const message of messages) {\n        await this.handleMessage(message);\n        \n        // Mark as read\n        this.agentCommunication.markMessageAsRead(message.id, this.agentId);\n      }\n    } catch (error) {\n      logger.error(`Error processing messages: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  /**\n   * Handle a message\n   */\n  private async handleMessage(message: Message): Promise<void> {\n    logger.info(`Handling message: ${message.subject} from ${message.from}`);\n    \n    try {\n      // Handle different message types\n      switch (message.type) {\n        case 'request':\n          await this.handleRequestMessage(message);\n          break;\n        case 'response':\n          await this.handleResponseMessage(message);\n          break;\n        case 'notification':\n          await this.handleNotificationMessage(message);\n          break;\n        case 'update':\n          await this.handleUpdateMessage(message);\n          break;\n      }\n    } catch (error) {\n      logger.error(`Error handling message: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  /**\n   * Handle a request message\n   */\n  private async handleRequestMessage(message: Message): Promise<void> {\n    // Check if it's a task assignment\n    if (message.subject.includes('Task assignment')) {\n      const taskContent = message.content;\n      \n      // Add to task manager\n      this.taskManager.addTask({\n        id: taskContent.taskId,\n        name: taskContent.taskName,\n        description: taskContent.taskDescription,\n        assignees: taskContent.assignees,\n        status: 'assigned'\n      });\n      \n      // Send acknowledgment\n      this.agentCommunication.replyToMessage(\n        message.id,\n        this.agentId,\n        {\n          status: 'accepted',\n          message: `Task \"${taskContent.taskName}\" accepted`\n        }\n      );\n      \n      logger.info(`Accepted task: ${taskContent.taskName}`);\n      \n      // Start working on the task\n      this.startWorking();\n    }\n    // Check if it's a research request\n    else if (message.subject.includes('Research request')) {\n      const researchContent = message.content;\n      \n      // Create a research task\n      const researchTask = new ResearchTask(\n        researchContent.topic,\n        researchContent.query,\n        researchContent.options || {}\n      );\n      \n      // Store the research task\n      this.researchTasks.set(researchTask.id, researchTask);\n      \n      // Send acknowledgment\n      this.agentCommunication.replyToMessage(\n        message.id,\n        this.agentId,\n        {\n          status: 'accepted',\n          message: `Research request accepted: ${researchTask.topic}`,\n          researchTaskId: researchTask.id\n        }\n      );\n      \n      logger.info(`Accepted research request: ${researchTask.topic}`);\n      \n      // Execute the research task\n      this.executeResearchTask(researchTask).then(result => {\n        // Send the result back to the requester\n        this.agentCommunication.sendMessage({\n          from: this.agentId,\n          to: message.from,\n          type: 'response',\n          subject: `Research results: ${researchTask.topic}`,\n          content: {\n            researchTaskId: researchTask.id,\n            topic: researchTask.topic,\n            query: researchTask.query,\n            results: result\n          }\n        });\n      }).catch(error => {\n        logger.error(`Error executing research task: ${error instanceof Error ? error.message : String(error)}`);\n        \n        // Send error message back to the requester\n        this.agentCommunication.sendMessage({\n          from: this.agentId,\n          to: message.from,\n          type: 'response',\n          subject: `Research error: ${researchTask.topic}`,\n          content: {\n            researchTaskId: researchTask.id,\n            topic: researchTask.topic,\n            error: error instanceof Error ? error.message : String(error)\n          }\n        });\n      });\n    }\n  }\n  \n  /**\n   * Handle a response message\n   */\n  private async handleResponseMessage(message: Message): Promise<void> {\n    // Implementation depends on what responses we expect\n    logger.debug(`Received response: ${JSON.stringify(message.content)}`);\n  }\n  \n  /**\n   * Handle a notification message\n   */\n  private async handleNotificationMessage(message: Message): Promise<void> {\n    // Check if it's a file share\n    if (message.subject.includes('Shared file')) {\n      const fileContent = message.content;\n      \n      logger.info(`Received shared file: ${fileContent.filePath}`);\n      \n      // Send acknowledgment\n      this.agentCommunication.replyToMessage(\n        message.id,\n        this.agentId,\n        {\n          status: 'received',\n          message: `File received: ${path.basename(fileContent.filePath)}`\n        }\n      );\n    }\n  }\n  \n  /**\n   * Handle an update message\n   */\n  private async handleUpdateMessage(message: Message): Promise<void> {\n    // Check if it's a task status update\n    if (message.subject.includes('Task status update')) {\n      const updateContent = message.content;\n      \n      // Update task in task manager\n      this.taskManager.updateTaskStatus(\n        updateContent.taskId,\n        updateContent.agentId,\n        updateContent.status,\n        updateContent.message\n      );\n      \n      logger.info(`Task ${updateContent.taskId} status updated to ${updateContent.status} by ${updateContent.agentId}`);\n    }\n  }\n  \n  /**\n   * Start working on tasks\n   */\n  private async startWorking(): Promise<void> {\n    logger.info('Starting work on tasks...');\n    \n    try {\n      // Get current task from task manager\n      const currentTask = this.taskManager.getCurrentTask();\n      \n      if (currentTask) {\n        // Update task status\n        this.taskManager.updateTaskStatus(\n          currentTask.id,\n          this.agentId,\n          'in_progress',\n          `Started working on ${currentTask.name}`\n        );\n        \n        // Execute the task\n        await this.executeTask(currentTask);\n        \n        // Update task status\n        this.taskManager.updateTaskStatus(\n          currentTask.id,\n          this.agentId,\n          'completed',\n          `Completed ${currentTask.name}`\n        );\n        \n        // Move to next task\n        if (this.taskManager.moveToNextTask()) {\n          // Continue working\n          await this.startWorking();\n        } else {\n          // No more tasks\n          this.agentCommunication.updateAgentStatus(this.agentId, 'idle');\n        }\n      } else {\n        // No tasks to work on\n        this.agentCommunication.updateAgentStatus(this.agentId, 'idle');\n      }\n    } catch (error) {\n      logger.error(`Error working on tasks: ${error instanceof Error ? error.message : String(error)}`);\n      this.agentCommunication.updateAgentStatus(this.agentId, 'idle');\n    }\n  }\n  \n  /**\n   * Execute a task\n   */\n  private async executeTask(task: any): Promise<void> {\n    logger.info(`Executing task: ${task.name}`);\n    \n    try {\n      // Simple task execution - just wait for a bit\n      await new Promise(resolve => setTimeout(resolve, 5000));\n      \n      // Log task completion\n      logger.info(`Task ${task.name} executed successfully`);\n    } catch (error) {\n      logger.error(`Error executing task ${task.name}: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n  \n  /**\n   * Execute a research task\n   */\n  private async executeResearchTask(task: ResearchTask): Promise<ResearchResult> {\n    logger.info(`Executing research task: ${task.topic}`);\n    \n    try {\n      // Get Ollama adapter\n      const ollamaAdapter = this.adapterManager.getFirstOllamaMCPAdapter();\n      \n      if (!ollamaAdapter) {\n        throw new Error('No Ollama adapter available for research');\n      }\n      \n      // Generate research prompt\n      const prompt = `\n        I need you to research the following topic: ${task.topic}\n        \n        Specific query: ${task.query}\n        \n        Please provide a comprehensive analysis including:\n        1. Key findings\n        2. Main concepts\n        3. Different perspectives\n        4. Relevant sources\n        5. A summary of the information\n        \n        Format your response as a structured research report.\n      `;\n      \n      // Generate research using Ollama\n      const researchText = await ollamaAdapter.generateText(prompt, 'llama3', {\n        temperature: 0.3,\n        max_tokens: 2000\n      });\n      \n      // Create research result\n      const result: ResearchResult = {\n        id: `result_${task.id}`,\n        taskId: task.id,\n        topic: task.topic,\n        query: task.query,\n        content: researchText,\n        timestamp: new Date().toISOString()\n      };\n      \n      // Save result to file\n      const resultDir = path.join(this.config.outputPath, 'research');\n      \n      if (!fs.existsSync(resultDir)) {\n        fs.mkdirSync(resultDir, { recursive: true });\n      }\n      \n      const resultPath = path.join(resultDir, `${result.id}.json`);\n      fs.writeFileSync(resultPath, JSON.stringify(result, null, 2));\n      \n      logger.info(`Research task ${task.topic} executed successfully`);\n      \n      return result;\n    } catch (error) {\n      logger.error(`Error executing research task ${task.topic}: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n}"
    },
    {
      "path": "src/ResearchTask.ts",
      "content": "/**\n * Research Task\n * \n * Represents a research task to be executed by the research agent.\n */\n\nexport class ResearchTask {\n  public id: string;\n  public topic: string;\n  public query: string;\n  public options: Record<string, any>;\n  public createdAt: string;\n  \n  constructor(topic: string, query: string, options: Record<string, any> = {}) {\n    this.id = `research_${Date.now()}_${Math.floor(Math.random() * 1000)}`;\n    this.topic = topic;\n    this.query = query;\n    this.options = options;\n    this.createdAt = new Date().toISOString();\n  }\n}"
    },
    {
      "path": "src/ResearchResult.ts",
      "content": "/**\n * Research Result\n * \n * Represents the result of a research task.\n */\n\nexport interface ResearchResult {\n  id: string;\n  taskId: string;\n  topic: string;\n  query: string;\n  content: string;\n  sources?: string[];\n  timestamp: string;\n}"
    }
  ],
  "dependencies": [
    "bootstrap-core"
  ],
  "setupInstructions": [
    "npm install",
    "npm run build",
    "npm start"
  ]
}
